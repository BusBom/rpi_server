# 버스 정류장 메인 서버 (Bus Butt Matcher)

## 1. 프로젝트 목표

이 프로그램은 정류장 서버로부터 실시간 플랫폼 점유 상태를 받아, 접근 중인 버스 목록과 대조하여 어떤 버스를 어느 플랫폼에 배차할지 **선제적으로 지시(Proactive Assignment)**하고, 그 결과를 드라이버에게 전달하는 **중앙 관제 시스템**입니다.

단순히 빈자리를 찾는 것을 넘어, 버스 정류장의 물리적 제약(선입선출)과 실시간 센서의 불안정성(깜빡임)을 모두 고려하여 안정적이고 정확한 배차를 결정하는 것을 목표로 합니다.

---

## 2. 핵심 동작 흐름

메인 서버는 무한 루프를 돌며 다음의 순서로 동작합니다.

### 2A. 데이터 수집
- **정류장 상태 수신**: `stop-status.cgi`에 주기적으로 HTTP 요청을 보내, 현재 플랫폼별 점유 상태(`platform_status`)를 받아옵니다.
- **접근 버스 목록 수신**: `bus-mapping.cgi`에 요청을 보내, 현재 정류장으로 접근 중인 버스 ID 목록(`incoming_bus_queue`)을 받아옵니다.

### 2B. 상태 안정화 (Stabilization)
- 센서 데이터는 버스가 움직이는 동안 `0`과 `1`을 오가며 불안정할 수 있습니다.
- `BusStationManager`는 센서 상태가 변경되면 **2초의 안정화 타이머**를 시작합니다.
- 2초 동안 추가적인 상태 변화가 없어야만, 해당 상태를 **'신뢰할 수 있는 상태'**로 확정하고 다음 단계를 진행합니다. 이 과정을 통해 센서의 일시적인 깜빡임이나 오류를 무시합니다.

### 2C. 이벤트 분석 및 처리
- 상태가 안정화되면, `BusStationManager`는 이전 상태와 현재 상태를 비교하여 다음과 같은 이벤트를 분석하고 확정합니다.
  - **신규 출차**: 특정 플랫폼의 버스가 떠났습니다.
  - **최종 출차**: 떠난 버스가 5초 이상 돌아오지 않았습니다.
  - **재정차**: 떠났던 버스가 다른 플랫폼으로 다시 진입했습니다.
  - **신규 도착**: 배차 지시를 받은 버스가 플랫폼에 도착했습니다.
- 확정된 이벤트에 따라 내부적으로 관리하는 버스-플랫폼 맵(`platform_to_bus_`)을 업데이트합니다.

### 2D. 신규 배차 지시 (Proactive Assignment)
- 시스템이 안정적인 상태일 때만 다음 배차를 결정합니다.
- 정류장 입구(가장 번호가 높은 플랫폼)부터 안쪽으로 확인하여, **물리적으로 진입 가능한 연속된 빈 플랫폼**을 찾습니다.
- 찾은 빈 플랫폼 중 가장 안쪽(번호가 가장 낮은) 자리부터, 대기 중인 버스를 순서대로 할당합니다.
- 이 배차 지시사항은 드라이버에게 전달될 최종 출력으로 생성됩니다.

### 2E. 최종 결과 출력
- 출차, 재정차, 신규 배차 등 모든 지시사항을 종합하여, 드라이버가 사용하는 하드웨어 형식에 맞게 콜론(`:`)으로 구분된 문자열로 변환하여 출력합니다.
- 예: `":"101":"102":" "` (플랫폼 0: 빈자리, 플랫폼 1: 101번, 플랫폼 2: 102번, 플랫폼 3: 빈자리)

---

## 3. 빌드 및 실행

### 3.1. 의존성
- **libcurl**: HTTP 통신을 위해 필요합니다.
- **nlohmann/json**: CGI가 반환하는 JSON 데이터를 파싱하기 위해 필요합니다.
- **C++11 이상**을 지원하는 컴파일러 (g++)

### 3.2. 빌드 방법
- 필요한 헤더 파일(`BusStationManager.h`, `bus_queue_fetcher.h` 등)이 모두 같은 디렉토리에 있다고 가정합니다.
- 다음 명령어로 컴파일할 수 있습니다.

```bash
g++ main.cpp BusStationManager.cpp bus_queue_fetcher.cpp -o main_server -lcurl -std=c++11 -pthread
```

### 3.3. 실행 전 설정
- `main.cpp` 파일 상단에 있는 CGI 주소를 실제 운영 환경에 맞게 수정해야 합니다.

```cpp
// main.cpp
const std::string stop_status_cgi_url = "https://platform_observer_address/cgi-bin/stop-status.cgi";
const std::string bus_mapping_cgi_url = "https://localhost/cgi-bin/bus-mapping.cgi";
```

### 3.4. 실행
- 빌드된 실행 파일을 터미널에서 실행합니다.

```bash
./bus_butt
